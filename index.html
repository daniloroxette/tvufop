<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TV UFOP — EDUPLAY</title>

  <!-- Evitar barra de tradução do Chrome -->
  <meta name="google" content="notranslate" />
  <meta http-equiv="Content-Language" content="pt-br" />

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#8C1B2B" />

  <!-- iOS “Add to Home Screen” -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="TV UFOP">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png">
  <link rel="apple-touch-icon" sizes="167x167" href="icons/apple-touch-icon-167.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/apple-touch-icon-152.png">
  <link rel="apple-touch-icon" sizes="120x120" href="icons/apple-touch-icon-120.png">

  <style>
    :root { --bordo:#8C1B2B; }
    *{ box-sizing:border-box }
    body{
      font-family: Arial, sans-serif;
      margin:0; padding:0; background:#fff; text-align:center;
    }
    h1{
      margin:0; padding:16px 12px; background:var(--bordo); color:#fff;
      font-size:20px; letter-spacing:.3px; position: sticky; top: 0; z-index: 1000;
    }
    .wrap{ width:min(100%, 960px); margin:16px auto; padding:0 8px; }

    /* PLAYER COM OVERLAY INTERNO */
    .player{
      position: sticky; width:100%; aspect-ratio:16/9; background:#000;
      border-radius:12px; overflow:hidden;
      top: calc(var(--header-h, 0px) + var(--gap-top, 6px)); z-index: 999;
    }
    .player iframe{ width:100%; height:100%; border:0; display:block; background:#000; }

    .eduplay-overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none; background: rgba(0,0,0,.55); color:#fff; opacity:1;
      transition: opacity .25s ease, visibility .25s ease;
    }
    .eduplay-overlay.is-hidden{ opacity:0; visibility:hidden; }
    .eduplay-overlay .overlay-content{
      display:inline-flex; gap:10px; align-items:center; padding:10px 14px;
      border-radius:12px; background:rgba(0,0,0,.35); backdrop-filter: blur(2px); font-size:1rem;
    }
    .eduplay-overlay .spinner{
      width:16px; height:16px; border-radius:50%;
      border:2px solid #bbb; border-top-color:#8C1B2B; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .logos{ margin:28px 0 40px; }
    .logos img{ margin:10px; vertical-align:middle; }
    .sep{ margin:18px 0; opacity:.3; }

    /* ===================== EPG CSS (inline) ===================== */
    #tvufop-epg {
      --tv-header-bg: #800020; /* vinho/bordô */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#1b1b1b;
    }
    #tvufop-epg .wrap{max-width:1080px;margin:0 auto;padding:12px;}
    #tvufop-epg .toolbar{
      display:flex;flex-wrap:wrap;gap:8px;align-items:center;
      background:var(--tv-header-bg);color:#fff;border-radius:10px;padding:10px 12px;
    }
    #tvufop-epg .toolbar .title{font-weight:700;font-size:18px;}
    #tvufop-epg .datebox{margin-left:auto;display:flex;gap:8px;align-items:center;}
    #tvufop-epg .date{font-weight:600;}
    #tvufop-epg .btn{border:0;border-radius:8px;padding:6px 10px;background:#e8e8e8;cursor:pointer}
    #tvufop-epg .btn:hover{background:#dcdcdc}
    #tvufop-epg .btn.ghost{background:transparent;color:#fff;border:1px solid #ffffff33}
    #tvufop-epg .btn.primary{background:#fff;color:#111}
    #tvufop-epg .search{display:flex}
    #tvufop-epg .search input{border:0;border-radius:8px;padding:7px 10px;min-width:200px;width:clamp(160px, 50vw, 320px);}
    #tvufop-epg .status{display:none;margin:10px 0;padding:9px 10px;border-radius:8px;background:#fff3cd;border:1px solid #ffe69c}
    #tvufop-epg .scroller{max-height:70vh;overflow:auto;padding-right:6px;margin-top:8px;scroll-behavior:smooth;}
    #tvufop-epg .hour-sep{
      position:sticky;top:0;background:#f6f6f6;border:1px solid #eee;border-left:3px solid #111;
      border-radius:8px;margin:10px 0 6px;padding:4px 8px;font-weight:700;width:max-content
    }
    #tvufop-epg .card{
      display:flex;gap:12px;align-items:center;border:1px solid #e9e9e9;border-radius:12px;
      padding:10px 12px;margin:6px 0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,.03);cursor:pointer
    }
    #tvufop-epg .card:hover{background:#fafafa}
    #tvufop-epg .card.now{border-color:#cfe6ff;background:#f1f8ff}
    #tvufop-epg .when{min-width:clamp(56px, 7.5vw, 88px);width:auto;font-variant-numeric:tabular-nums;}
    #tvufop-epg .when .end{opacity:.7;margin-left:8px}
    #tvufop-epg .info{flex:1 1 auto;min-width:0}
    #tvufop-epg .card .title{font-weight:600}
    #tvufop-epg .meta{opacity:.7;font-size:.9em;margin-top:2px}
    #tvufop-epg .badge-now{margin-left:8px;font-size:.75em;background:#0075ff;color:#fff;border-radius:999px;padding:2px 7px;vertical-align:middle}
    #tvufop-epg dialog{border:0;border-radius:14px;max-width:760px;width:calc(100% - 24px)}
    #tvufop-epg .modal{display:block;padding:16px}
    #tvufop-epg .m-title{font-weight:700;font-size:18px}
    #tvufop-epg .times{opacity:.8;margin:4px 0 8px}
    @media (max-width: 560px){
      #tvufop-epg .toolbar{
        display:grid;
        grid-template-columns:1fr auto;
        grid-template-rows:auto auto;
        grid-template-areas:
          "title datebox"
          "search now";
        gap:8px 12px;align-items:center;justify-items:stretch;text-align:initial;
      }
      #tvufop-epg .toolbar .title{grid-area:title;text-align:left}
      #tvufop-epg .datebox{grid-area:datebox;margin-left:0;justify-content:flex-end;display:inline-flex;gap:8px;align-items:center;}
      #tvufop-epg .search{grid-area:search;width:100%}
      #tvufop-epg .search input{width:100%;min-width:0}
      #tvufop-epg .btn.primary[data-role="nowBtn"]{grid-area:now;justify-self:end}
    }
    #tvufop-epg .m-row{display:flex;gap:16px;align-items:flex-start;}
    #tvufop-epg .m-thumb{
      flex:0 0 auto;width:clamp(140px, 26vw, 220px);aspect-ratio:89/50;object-fit:cover;
      border-radius:10px;border:1px solid #eee;background:#f3f3f3;
    }
    #tvufop-epg .m-col{flex:1 1 auto;min-width:0}
    #tvufop-epg .desc{margin-top:8px;line-height:1.35}
    @media (max-width:460px){
      #tvufop-epg .m-row{flex-direction:column;align-items:stretch}
      #tvufop-epg .m-thumb{width:100%;aspect-ratio:89/50;}
    }
  </style>
</head>
<body>
  <h1>TV UFOP — EDUPLAY</h1>

  <div class="wrap">
    <!-- Player Eduplay com overlay interno -->
    <div class="player" id="eduplay-box">
      <iframe
        id="eduplay-iframe"
        src="https://eduplay.rnp.br/app/tv/embed/ufop"
        title="Player Eduplay"
        allow="autoplay *; fullscreen *; picture-in-picture *; encrypted-media *"
        referrerpolicy="strict-origin-when-cross-origin"
        allowfullscreen
        tabindex="0">
      </iframe>

      <div id="eduplay-overlay" class="eduplay-overlay" role="status" aria-live="polite" aria-busy="true">
        <div class="overlay-content">
          <span class="spinner" aria-hidden="true"></span>
          <span class="msg">Carregando Eduplay…</span>
        </div>
      </div>
    </div>

    <div class="logos">
      <p><img src="images/logo_tvufop_eduplay.png" alt="TV UFOP Eduplay" height="50"></p>
      <p><img src="images/logo-fundac.png" alt="FUNDAC" height="80"></p>
      <p><strong>Fundação de Educação, Artes e Cultura</strong></p>
      <p><em>Desde 2022, o trabalho da TV UFOP é mantido através de convênio entre a UFOP e a FUNDAC.</em></p>
    </div>

    <!-- Viewport rolável só da programação -->
    <div id="epg-viewport" role="region" aria-label="Programação">
      <div id="tvufop-epg"></div>
    </div>
  </div>

  <!-- Calcula alturas do cabeçalho e do player para layout sticky -->
  <script>
    (function(){
      const header = document.querySelector('h1');
      const player = document.getElementById('eduplay-box');
      function updateVars(){
        if (header) document.documentElement.style.setProperty('--header-h', header.offsetHeight + 'px');
        if (player) {
          const r = player.getBoundingClientRect();
          document.documentElement.style.setProperty('--player-h', r.height + 'px');
        }
        document.documentElement.style.setProperty('--gap-top', '6px'); // controla o espaço extra
      }
      window.addEventListener('load', updateVars);
      window.addEventListener('resize', updateVars);
    })();
  </script>

  <!-- ====== EPG (loader + UI) – conteúdo do antigo epg/epg.js ====== -->
  <script>
    (function () {
      // ===== Preferências de origem do JSON =====
      function candidateUrls() {
        const base = document.baseURI || location.href;
        const here = base.replace(/[#?].*$/, "");
        const root = here.replace(/\/[^/]*$/, "/");
        // Prioridade: servidor (mais atual) -> Pages -> raw -> local
        const arr = [
          "https://tvufop.com.br/epg/schedule_now.json",
          "https://raw.githubusercontent.com/daniloroxette/tvufop/main/epg/schedule_now.json",
          "epg/schedule_now.json",
          root + "epg/schedule_now.json",
          location.origin + "/epg/schedule_now.json",
        ];
        return Array.from(new Set(arr));
      }

      // ===== Utilidades =====
      const pad = n => String(n).padStart(2, "0");
      const fmtTime = d => `${pad(d.getHours())}:${pad(d.getMinutes())}`;
      const fmtDate = d => `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}`;
      const onlyDate = d => new Date(d.getFullYear(), d.getMonth(), d.getDate());

      function extractSchedule(data){
        if (Array.isArray(data)) return data;
        if (data && Array.isArray(data.schedule)) return data.schedule;
        if (data && Array.isArray(data.items)) return data.items;
        if (data && Array.isArray(data.programs)) return data.programs;
        throw new Error('JSON válido, porém sem campo "schedule" (ou lista reconhecida).');
      }

      // ===== Fetch com timeout e corrida =====
      function fetchWithTimeout(url, ms, opts) {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), ms);
        return fetch(url, { ...opts, signal: ctrl.signal }).finally(() => clearTimeout(t));
      }

      function firstFulfilled(promises) {
        return new Promise((resolve, reject) => {
          let pend = promises.length, lastErr;
          for (const p of promises) {
            Promise.resolve(p).then(resolve, e => { lastErr = e; if (--pend === 0) reject(lastErr); });
          }
        });
      }

      // Dispara por prioridade com pequenos atrasos (stagger), mas ainda em paralelo.
      async function fetchScheduleStaggered(urls, onProgress, perUrlTimeoutMs = 2500, overallTimeoutMs = 7000, staggerMs = 220) {
        onProgress?.(""); // silencioso
        const overallTimeout = new Promise((_, rej) =>
          setTimeout(() => rej(new Error("Tempo excedido carregando a programação")), overallTimeoutMs)
        );
        const attempts = urls.map((u, i) => new Promise((resolve, reject) => {
          setTimeout(async () => {
            try {
              const res = await fetchWithTimeout(u, perUrlTimeoutMs, { cache: "no-store" });
              if (!res.ok) throw new Error(`HTTP ${res.status} em ${u}`);
              const json = await res.json();
              const schedule = extractSchedule(json);
              resolve({ url: u, schedule });
            } catch (e) {
              reject(new Error(`${u}: ${e.message || e}`));
            }
          }, i * staggerMs);
        }));
        const winner = await firstFulfilled([overallTimeout, ...attempts]);
        onProgress?.("");
        return winner;
      }

      // ===== Loader de thumbs (prioriza GitHub Pages) =====
      function loadWithImgTimeout(url, ms) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const to = setTimeout(() => { img.src = ""; reject(new Error("timeout")); }, ms);
          img.onload = () => { clearTimeout(to); resolve(url); };
          img.onerror = () => { clearTimeout(to); reject(new Error("error")); };
          img.referrerPolicy = "no-referrer-when-downgrade";
          img.src = url;
        });
      }

      function stagedImageRace(urls, stepDelay = 600, perUrlTimeout = 3000, overallTimeout = 8000) {
        const runners = urls.map((u, i) => new Promise((resolve, reject) => {
          setTimeout(() => {
            loadWithImgTimeout(u, perUrlTimeout).then(resolve).catch(reject);
          }, i * stepDelay);
        }));
        const kill = new Promise((_, rej) => setTimeout(() => rej(new Error("img overall timeout")), overallTimeout));
        return firstFulfilled([kill, ...runners]);
      }

      function loadThumbPreferGithub(originalThumbUrl, imgEl, title) {
        imgEl.style.display = "none";
        imgEl.removeAttribute("src");
        imgEl.alt = title || "";
        let base = "";
        if (originalThumbUrl) {
          const last = originalThumbUrl.split("/").pop() || "";
          base = (last.split("?")[0] || "").trim();
          try { base = decodeURIComponent(base); } catch { /* ignore */ }
        }
        if (!base) return;
        const enc = encodeURIComponent(base);
        const candidates = [
          `https://tvufop.com.br/thumbs/${enc}`,
          `thumbs/${enc}`,
          `https://app.tvufop.com.br/epg/${enc}`
        ];
        stagedImageRace(candidates)
          .then(url => { imgEl.src = url; imgEl.decoding = "async"; imgEl.loading = "eager"; imgEl.style.display = ""; })
          .catch(() => { imgEl.style.display = "none"; });
      }

      // ===== UI =====
      function mount(container){
        if (container.__wired) return;
        container.__wired = true;

        container.innerHTML =
          '<div class="tv-header"><div class="wrap toolbar">'
          +   '<div class="title">Programação</div>'
          +   '<div class="datebox">'
          +     '<button class="btn ghost" data-role="prev" title="Dia anterior" aria-label="Dia anterior">◀</button>'
          +     '<div class="date" data-role="dateLabel">—</div>'
          +     '<button class="btn ghost" data-role="next" title="Próximo dia" aria-label="Próximo dia">▶</button>'
          +   '</div>'
          +   '<div class="search"><input data-role="q" placeholder="Filtrar por título…"></div>'
          +   '<button class="btn primary" data-role="nowBtn" title="Ir para o programa em execução">Agora</button>'
          + '</div></div>'
          + '<div class="tv-main"><div class="wrap">'
          +   '<div class="status" data-role="status" style="display:none"></div>'
          +   '<div class="scroller" aria-label="Lista de programas">'
          +     '<div class="list" data-role="list" role="list"></div>'
          +     '<div class="empty" data-role="empty" hidden>Nenhuma entrada para o dia selecionado.</div>'
          +   '</div>'
          + '</div></div>'
          + '<dialog data-role="dlg"><div class="modal">'
          +   '<div class="m-row">'
          +     '<img class="m-thumb" data-role="dlgThumb" alt="" />'
          +     '<div class="m-col">'
          +       '<div class="m-title" data-role="dlgTitle">—</div>'
          +       '<div class="times" data-role="dlgTimes">—</div>'
          +       '<div class="desc" data-role="dlgDesc" style="display:none"></div>'
          +     '</div>'
          +   '</div>'
          + '</div></dialog>';

        const els = {
          list: container.querySelector('[data-role="list"]'),
          empty: container.querySelector('[data-role="empty"]'),
          dateLabel: container.querySelector('[data-role="dateLabel"]'),
          prev: container.querySelector('[data-role="prev"]'),
          next: container.querySelector('[data-role="next"]'),
          q: container.querySelector('[data-role="q"]'),
          nowBtn: container.querySelector('[data-role="nowBtn"]'),
          status: container.querySelector('[data-role="status"]'),
          dlg: container.querySelector('[data-role="dlg"]'),
          dlgTitle: container.querySelector('[data-role="dlgTitle"]'),
          dlgTimes: container.querySelector('[data-role="dlgTimes"]'),
          dlgDesc: container.querySelector('[data-role="dlgDesc"]'),
          dlgThumb: container.querySelector('[data-role="dlgThumb"]'),
          scroller: container.querySelector('.scroller'),
        };

        let programs=[], days=[], dayIndex=0;

        const showStatus = (msg, { error = false } = {}) => {
          if (!error) {
            els.status.textContent = "";
            els.status.style.display = "none";
            return;
          }
          els.status.textContent = msg || "";
          els.status.style.display = msg ? "block" : "none";
        };

        function hydrate(list){
          programs = list.map(p=>{
            const start = new Date(p.start), stop = new Date(p.stop);
            return {
              start, stop,
              title: (p.title || "").trim(),
              desc: (p.desc || "").trim(),
              rating: (p.rating || "").trim(),
              thumb: (p.thumb || "").trim(),
              duration: Number.isFinite(stop - start) ? Math.round((stop - start) / 60000) : null
            };
          }).sort((a,b)=>a.start - b.start);

          const set = new Set(programs.map(p => onlyDate(p.start).toISOString()));
          days = Array.from(set).map(s => new Date(s)).sort((a,b)=>a - b);

          const idxToday = indexForToday();
          dayIndex = (idxToday >= 0) ? idxToday : 0;
          renderDay();
        }

        function indexForToday(){
          if (!days.length) return -1;
          const today = onlyDate(new Date());
          const exact = days.findIndex(d => d.toISOString() === today.toISOString());
          if (exact >= 0) return exact;
          let best = 0, bestDiff = Math.abs(days[0] - today);
          for (let i=1;i<days.length;i++){
            const diff = Math.abs(days[i] - today);
            if (diff < bestDiff){ best = i; bestDiff = diff; }
          }
          return best;
        }

        function renderDay(){
          if(!days.length){
            els.list.innerHTML=''; els.empty.hidden=false; els.dateLabel.textContent='—'; return;
          }
          const day = days[dayIndex];
          els.dateLabel.textContent = fmtDate(day);
          const dayEnd = new Date(day); dayEnd.setDate(day.getDate()+1);
          const rows = programs.filter(p => p.start >= day && p.start < dayEnd);
          renderList(rows, els.q.value.trim());
          els.prev.disabled = dayIndex <= 0;
          els.next.disabled = dayIndex >= days.length - 1;
        }

        function renderList(rows, query){
          const list=els.list; list.innerHTML='';
          const q=(query||'').toLowerCase();
          const kept = rows.filter(p => !q || p.title.toLowerCase().includes(q));
          els.empty.hidden = kept.length > 0;

          const now=new Date(); let lastHour=-1;
          kept.forEach(p=>{
            const h=p.start.getHours();
            if(h!==lastHour){ lastHour=h;
              const sep=document.createElement('div'); sep.className='hour-sep'; sep.textContent=`${pad(h)}:00`; list.appendChild(sep);
            }
            const card=document.createElement('div'); card.className='card'; card.setAttribute('role','button'); card.setAttribute('tabindex','0');
            card.dataset.start=p.start.toISOString(); card.dataset.stop=p.stop.toISOString();
            card.addEventListener('click',()=>openModal(p));
            card.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); openModal(p);} });

            const when=document.createElement('div'); when.className='when';
            when.innerHTML=`<span class="start">${fmtTime(p.start)}</span>`;

            const info=document.createElement('div'); info.className='info';
            const title=document.createElement('div'); title.className='title'; title.textContent=p.title||'(Sem título)';
            const meta=document.createElement('div'); meta.className='meta'; meta.textContent=`${p.duration ?? '–'} min`;
            info.appendChild(title); info.appendChild(meta);

            card.appendChild(when); card.appendChild(info);

            if(now>=p.start && now<p.stop){
              card.classList.add('now');
              const badge=document.createElement('span'); badge.className='badge-now'; badge.textContent='AGORA'; title.appendChild(badge);
            }
            list.appendChild(card);
          });
        }

        function openModal(p){
          loadThumbPreferGithub(p.thumb, els.dlgThumb, p.title);
          els.dlgTitle.textContent = p.title || "(Sem título)";
          const rating = p.rating ? `  •  ${p.rating}` : "";
          els.dlgTimes.textContent = `${fmtTime(p.start)} – ${fmtTime(p.stop)}  •  ${p.duration ?? '–'} min${rating}`;
          if (p.desc && p.desc.trim()){
            els.dlgDesc.textContent = p.desc.trim();
            els.dlgDesc.style.display = "block";
          } else {
            els.dlgDesc.textContent = "";
            els.dlgDesc.style.display = "none";
          }
          if (els.dlg.showModal) els.dlg.showModal(); else els.dlg.setAttribute('open','');
        }

        function scrollToNow(){
          const scroller=els.scroller; if(!scroller) return;
          const now=new Date();
          let target=els.list.querySelector('.card.now');
          if(!target){
            const cards=[...els.list.querySelectorAll('.card')];
            const next=cards.map(c=>({el:c, st:new Date(c.dataset.start)})).filter(x=>!isNaN(x.st))
                            .sort((a,b)=>a.st-b.st).find(x=>x.st>=now);
            if(next) target=next.el;
          }
          if(!target) target=els.list.querySelector('.card:last-of-type');
          if(!target) return;
          const y = target.getBoundingClientRect().top - scroller.getBoundingClientRect().top + scroller.scrollTop - 8;
          scroller.scrollTo({top:y, behavior:'smooth'}); target.focus({preventScroll:true});
        }

        function tickNow(){
          const now=new Date();
          els.list.querySelectorAll('.card').forEach(card=>{
            const st=new Date(card.dataset.start), en=new Date(card.dataset.stop);
            const isNow=now>=st && now<en, wasNow=card.classList.contains('now');
            if(isNow && !wasNow){
              card.classList.add('now');
              const t=card.querySelector('.title'); if(t && !t.querySelector('.badge-now')){
                const b=document.createElement('span'); b.className='badge-now'; b.textContent='AGORA'; t.appendChild(b);
              }
            } else if(!isNow && wasNow){
              card.classList.remove('now'); const b=card.querySelector('.badge-now'); if(b) b.remove();
            }
          });
        }

        // Controles
        els.prev.addEventListener('click', ()=>{ if(dayIndex>0){ dayIndex--; renderDay(); } });
        els.next.addEventListener('click', ()=>{ if(dayIndex<days.length-1){ dayIndex++; renderDay(); } });
        els.q.addEventListener('input',  ()=>{ renderDay(); });
        els.nowBtn.addEventListener('click', ()=>{
          const idx=indexForToday();
          if(idx>=0){ dayIndex=idx; renderDay(); requestAnimationFrame(()=>scrollToNow()); }
        });
        els.dlg.addEventListener('click', (e)=>{ if(e.target===els.dlg) els.dlg.close(); });

        (async function init(){
          try{
            const {url, schedule}=await fetchScheduleStaggered(candidateUrls(), null);
            hydrate(schedule);
            console.info("EPG de:", url);
            if (els.status && els.status.parentNode) els.status.parentNode.removeChild(els.status);
          } catch(e){
            console.error(e);
            showStatus(`Falha ao carregar a programação. ${e.message||e}`, { error: true });
          }
          clearInterval(container.__tick); container.__tick=setInterval(tickNow, 60*1000);
        })();
      }

      if (document.readyState==='loading'){
        document.addEventListener('DOMContentLoaded', ()=>{
          const host=document.getElementById('tvufop-epg'); if(host) mount(host);
        });
      } else {
        const host=document.getElementById('tvufop-epg'); if(host) mount(host);
      }
    })();
  </script>

  <!-- ====== EPG – scroll interno com "gating" por visibilidade ====== -->
  <script>
    (function(){
      const viewport = document.getElementById('epg-viewport');
      const root     = document.getElementById('tvufop-epg');

      // Estilo do container scrollável do EPG
      Object.assign(viewport.style, {
        maxHeight: 'calc(100svh - var(--header-h,0px) - var(--player-h,0px) - 28px)',
        overflowY: 'auto',
        overscrollBehavior: 'contain',
        borderRadius: '12px',
        WebkitOverflowScrolling: 'touch',
        touchAction: 'pan-y'
      });

      const SAFE_OFFSET = 125;
      viewport.style.scrollPaddingTop = (48 + SAFE_OFFSET) + 'px';

      const q  = (sel, el=root) => el.querySelector(sel);
      const qa = (sel, el=root) => Array.from(el.querySelectorAll(sel));
      const relTop = (el, container=viewport) => {
        const e = el.getBoundingClientRect();
        const c = container.getBoundingClientRect();
        return (e.top - c.top) + container.scrollTop;
      };

      function firstItem(){ return q('li, .epg-item, tr, .row, .program, article'); }

      function findNow(){
        const sels = ['.is-now','.now','[data-now="true"]','[aria-current="true"]','[data-state~="now"]'];
        for (const s of sels){ const el = q(s); if (el) return el; }
        const items = qa('li, .epg-item, tr, .row, .program, article')
          .filter(el => /\b\d{2}:\d{2}\b/.test(el.textContent));
        if (!items.length) return null;
        const now = new Date();
        const nowMin = now.getHours()*60 + now.getMinutes();
        let best=null, bestVal=-1;
        for (const el of items){
          const m = el.textContent.match(/\b(\d{2}):(\d{2})\b/);
          if (!m) continue;
          const t = (+m[1])*60 + (+m[2]);
          const val = (t<=nowMin)? t : (t-1440);
          if (val>bestVal){bestVal=val; best=el;}
        }
        return best;
      }

      function stickHeader(){
        const header = root.firstElementChild;
        if (!header) return 0;
        Object.assign(header.style, { position: 'sticky', top: '0', zIndex: '2', background: '#fff' });
        return header.getBoundingClientRect().height || 0;
      }

      function effectiveGap(){
        const prev = viewport.scrollTop;
        viewport.scrollTop = 0;
        const first = firstItem();
        const headerGap = first ? relTop(first) : 0;
        viewport.scrollTop = prev;
        const gap = Math.max(0, headerGap + SAFE_OFFSET);
        viewport.style.scrollPaddingTop = gap + 'px';
        return gap;
      }

      function scrollToNow(opts={smooth:false}){
        const nowEl = findNow();
        if (!nowEl) return;
        stickHeader();
        const gap = effectiveGap();
        const target = Math.max(0, relTop(nowEl) - gap);
        viewport.scrollTo({ top: target, behavior: opts.smooth ? 'smooth':'auto' });
      }

      function squashInnerScrollers(){
        qa('*').forEach(el => {
          const cs = getComputedStyle(el);
          if (/(auto|scroll)/.test(cs.overflowY)) el.style.overflowY = 'visible';
          if (cs.maxHeight && cs.maxHeight !== 'none') el.style.maxHeight = 'none';
        });
      }

      // ====== GATING por visibilidade (IntersectionObserver) ======
      let allowAutoAlign = false; // libera o auto-align somente quando o guia ficar visível
      let done = false;           // evita múltiplos alinhamentos automáticos

      const io = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (e.isIntersecting && e.intersectionRatio > 0.15) {
            allowAutoAlign = true;
            initAlign();     // alinha uma vez, agora que o guia está à vista
            io.disconnect(); // não observar mais
            break;
          }
        }
      }, { root: null, threshold: [0, 0.15, 0.5] });

      io.observe(viewport);

      function initAlign(force = false){
        if (done) return;
        if (!force && !allowAutoAlign) return;   // só roda quando visível (ou forçado)
        squashInnerScrollers();
        stickHeader();
        requestAnimationFrame(() => {
          scrollToNow({ smooth: false });
          done = true;
        });
      }

      // Clique no “Agora” (força alinhamento mesmo que ainda não tenha cruzado o limiar do IO)
      viewport.addEventListener('click', (ev) => {
        const btn = ev.target.closest('button,[role="button"],a');
        if (!btn) return;
        if (/agora/i.test(btn.textContent || '')) {
          ev.preventDefault();
          allowAutoAlign = true;
          done = false;
          scrollToNow({ smooth: true });
        }
      });

      // Quando a UI do EPG aparecer/atualizar, tenta alinhar (respeitando o gating)
      const mo = new MutationObserver(() => initAlign());
      mo.observe(root, { childList: true, subtree: true });

      // Importante: não alinhar no load da página (mantém logomarcas estáticas no topo)
      // window.addEventListener('load', initAlign);

      // Em resize, se o guia estiver visível, re-alinha
      window.addEventListener('resize', () => { done = false; initAlign(); });
    })();
  </script>

  <!-- Overlay: lógica de exibição -->
  <script>
    (function(){
      const iframe  = document.getElementById('eduplay-iframe');
      const overlay = document.getElementById('eduplay-overlay');
      if (!iframe || !overlay) return;

      overlay.classList.remove('is-hidden');

      iframe.addEventListener('load', () => {
        setTimeout(() => {
          overlay.classList.add('is-hidden');
          overlay.setAttribute('aria-busy', 'false');
        }, 500);
      });

      new MutationObserver(muts => {
        for (const m of muts) {
          if (m.type === 'attributes' && m.attributeName === 'src') {
            overlay.querySelector('.msg').textContent = 'Carregando Eduplay…';
            overlay.classList.remove('is-hidden');
            overlay.setAttribute('aria-busy', 'true');
          }
        }
      }).observe(iframe, { attributes: true, attributeFilter: ['src'] });

      setTimeout(() => {
        if (!overlay.classList.contains('is-hidden')) {
          overlay.querySelector('.msg').textContent = 'Carregando Eduplay… (verifique a conexão)';
        }
      }, 12000);
    })();
  </script>

  <!-- Service Worker -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js', { scope: './' })
          .catch(err => console.log('SW registration failed:', err));
      });
    }
  </script>
</body>
</html>
